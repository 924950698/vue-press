# RegExp篇二

```type={1,2,11,12}
/***
 *
 * ███████▒█    ██  ▄████▄   ██ ▄█▀       ██████╗ ██╗   ██╗ ██████╗
 * ▓██   ▒ ██  ▓██▒▒██▀ ▀█   ██▄█▒        ██╔══██╗██║   ██║██╔════╝
 * ▒████ ░▓██  ▒██░▒▓█    ▄ ▓███▄░        ██████╔╝██║   ██║██║  ███╗
 * ░▓█▒  ░▓▓█  ░██░▒▓▓▄ ▄██▒▓██ █▄        ██╔══██╗██║   ██║██║   ██║
 * ░▒█░   ▒▒█████▓ ▒ ▓███▀ ░▒██▒ █▄       ██████╔╝╚██████╔╝╚██████╔╝
 *  ▒ ░   ░▒▓▒ ▒ ▒ ░ ░▒ ▒  ░▒ ▒▒ ▓▒       ╚═════╝  ╚═════╝  ╚═════╝
 *  ░     ░░▒░ ░ ░   ░  ▒   ░ ░▒ ▒░
 *  ░ ░    ░░░ ░ ░ ░        ░ ░░ ░
 *           ░     ░ ░      ░  ░
 */

```

## 正则要么匹配字符，要么匹配位置。
元字符：
* 两种模糊匹配
* 字符组
* 量词
* 分支结构
* 案例分析

1. 纵向匹配 和 横向匹配
2. 字符组：范围表示法 [] ， 
 <br> 排除字符组 ^（脱字符），
 <br> 范围字符组 /d , /D , /w , /W , /s , /S 和 . 七种。请看下图：



3. 量词 
**简写形式** {m,}
4. 贪婪与惰性匹配
**贪婪匹配：** 条件范围内，越多越好。<br>
**惰性匹配：** 条件范围内，尽可能少的匹配。通过在量词后面加个？就可以实现惰性匹配。

5. 多选分支
| （管道符，或）也是惰性的，匹配上以后就不会在继续匹配了。

6. 匹配十六进制的颜色

```type={15}
var regex = /#\w{3,6}/ig
var string = "#ffbbad #Fc01DF #FFF #ffE";
console.log( string.match(regex) );
//输出：#ffbbad #Fc01DF #FFF #ffE

var regex = /#\w{3,6}$/ig
var string = "#ffbbad #Fc01DF #FFF #ffE";
console.log( string.match(regex) );

/* 重点1：
	加上$符号以后，为啥只能匹配一条 #ffE ？
	$限定结尾，又因为正则表达式中，含有“#”；所以只能是从最后一个“#”开头的字符串开始。
*/

//如果换成：var regex = /^#\w{3,6}$/ig

/* 重点2：
	结果就会变成null。因为：string是一个字符串，不是4个字符串。
	而以“#”号开头，以最后一位字母结尾。已经不是在3-6位之间了。
	所以，string是不符合regex规则的，返回null。
*/
```

7. 匹配时间（以24小时为例），实现以下匹配:

**23:59 <br>
02:07**

```type={1}
//这道题需要想一下，24时制的4位数字分别有什么特征。

var regex = /([01][0-9]|[2][0-3]):([0-5][0-9])/g
var date = '23:59 02:07'
console.log(date.match(regex))// 输出23:59 02:07
```

现在加入也需要匹配：7:9 （时分前面的“0”可以省略）的情况呢？



8. 


























