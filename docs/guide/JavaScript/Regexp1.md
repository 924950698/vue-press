# RegExp篇二

```type={1,2,11,12}
/***
 *
 * ███████▒█    ██  ▄████▄   ██ ▄█▀       ██████╗ ██╗   ██╗ ██████╗
 * ▓██   ▒ ██  ▓██▒▒██▀ ▀█   ██▄█▒        ██╔══██╗██║   ██║██╔════╝
 * ▒████ ░▓██  ▒██░▒▓█    ▄ ▓███▄░        ██████╔╝██║   ██║██║  ███╗
 * ░▓█▒  ░▓▓█  ░██░▒▓▓▄ ▄██▒▓██ █▄        ██╔══██╗██║   ██║██║   ██║
 * ░▒█░   ▒▒█████▓ ▒ ▓███▀ ░▒██▒ █▄       ██████╔╝╚██████╔╝╚██████╔╝
 *  ▒ ░   ░▒▓▒ ▒ ▒ ░ ░▒ ▒  ░▒ ▒▒ ▓▒       ╚═════╝  ╚═════╝  ╚═════╝
 *  ░     ░░▒░ ░ ░   ░  ▒   ░ ░▒ ▒░
 *  ░ ░    ░░░ ░ ░ ░        ░ ░░ ░
 *           ░     ░ ░      ░  ░
 */

```
# 第一章 正则表达式字符匹配攻略

## 正则要么匹配字符，要么匹配位置。
元字符：
* 两种模糊匹配
* 字符组
* 量词
* 分支结构
* 案例分析

1. 纵向匹配 和 横向匹配
2. 字符组：范围表示法 [] ， 
 <br> 排除字符组 ^（脱字符），
 <br> 范围字符组 /d , /D , /w , /W , /s , /S 和 . 七种。请看下图：



3. 量词 
**简写形式** {m,}
4. 贪婪与惰性匹配
**贪婪匹配：** 条件范围内，越多越好。<br>
**惰性匹配：** 条件范围内，尽可能少的匹配。通过在量词后面加个？就可以实现惰性匹配。

5. 多选分支
| （管道符，或）也是惰性的，匹配上以后就不会在继续匹配了。

6. 匹配十六进制的颜色

```type={15}
var regex = /#\w{3,6}/ig
var string = "#ffbbad #Fc01DF #FFF #ffE";
console.log( string.match(regex) );
//输出：#ffbbad #Fc01DF #FFF #ffE

var regex = /#\w{3,6}$/ig
var string = "#ffbbad #Fc01DF #FFF #ffE";
console.log( string.match(regex) );

/* 重点1：
	加上$符号以后，为啥只能匹配一条 #ffE ？
	$限定结尾，又因为正则表达式中，含有“#”；所以只能是从最后一个“#”开头的字符串开始。
*/

//如果换成：var regex = /^#\w{3,6}$/ig

/* 重点2：
	结果就会变成null。因为：string是一个字符串，不是4个字符串。
	而以“#”号开头，以最后一位字母结尾。已经不是在3-6位之间了。
	所以，string是不符合regex规则的，返回null。
*/
```

7. 匹配时间（以24小时为例），实现以下匹配:

**23:59 <br>
02:07**

```type={1}
//这道题需要想一下，24时制的4位数字分别有什么特征。

var regex = /([01][0-9]|[2][0-3]):([0-5][0-9])/g
var date = '23:59 02:07'
console.log(date.match(regex))// 输出23:59 02:07
```

现在加入也需要匹配：7:9 （时分前面的“0”可以省略）的情况呢？
```
  var regex = /(0?[0-9]|1[0-9]|[2][0-3]):(0?[0-9]|[1-5][0-9])/g;
  var date = '23:59 02:07 7:9'
  console.log(date.match(regex))//输出：23:59 02:07 7:9
```
**Tips：**<br>
	写到这，觉得"^" 和 "$"这两个字符有必要总结一下。这两个限定符不能随便用，之前没注意到，踩了太多坑。<br>如果想匹配这种"aa ab ac ba bd"
的字符串格式下的子串。一旦限定开头和结尾，由于搜索的是一整个字符串，所以结果马上就变得截然相反。大家慎用。

8. 匹配日期 2017-09-09

```
	var regex = /[0-9]{4}\-(0?[1-9]|1[0-2])\-([0-2][0-9]|3[0-1])/g
	var date = '2017-09-09'
	console.log(date.match(regex))
```

**上面的正则没有考虑到“日”为一位数时，不能是0的情况。即“2019-09-00”，正常情况下是不会有这种情况出现的。**

```
	/[0-9]{4}\-(0?[1-9]|1[0-2])\-(0[1-9]|[12][0-9]|3[01])/g
```

**Tips：**
另外，使用“[]”范围符时，如果是1-2，2-3这种相邻的范围。可以把-省略掉。

9. window 操作系统文件路径匹配

**因为文件夹的名字不能是特殊字符，那么就要首先确定一个问题：js的正则中的特殊字符都有哪些？**

```
初步断定有以下几种：
~!@#$%^&*()/\|,.<>?"'();:_+-=\[\]{}

var regex = /^[a-zA-Z]:\\([^\\:*<>|"?\r\n/]+\\)*([^\\:*<>|"?\r\n/]+)?$/;
console.log( regex.test("F:\\study\\javascript\\regex\\regular expression.pdf") );
console.log( regex.test("F:\\study\\javascript\\regex\\") );
console.log( regex.test("F:\\study\\javascript") );
console.log( regex.test("F:\\") );
// => true
// => true
// => true
// => true
```

10. 匹配id

```
var string='<div id="container" class="main"></div>'
var regex = /id=".*"/
输出：id="container" class="main"

Tips:
	因为*是贪婪匹配，所以会一直匹配到最后一个"才结束。
	所以，我们加一个?使用非贪婪模式来匹配即可。

var string='<div id="container" class="main"></div>'
var regex = /id=".*?"/
输出：id="container"
```

**后记：**
<br>	这一章练习一些基本的正则操作习题。


----------


```
/***
 * ┌───┐   ┌───┬───┬───┬───┐ ┌───┬───┬───┬───┐ ┌───┬───┬───┬───┐ ┌───┬───┬───┐
 * │Esc│   │ F1│ F2│ F3│ F4│ │ F5│ F6│ F7│ F8│ │ F9│F10│F11│F12│ │P/S│S L│P/B│  ┌┐    ┌┐    ┌┐
 * └───┘   └───┴───┴───┴───┘ └───┴───┴───┴───┘ └───┴───┴───┴───┘ └───┴───┴───┘  └┘    └┘    └┘
 * ┌───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───────┐ ┌───┬───┬───┐ ┌───┬───┬───┬───┐
 * │~ `│! 1│@ 2│# 3│$ 4│% 5│^ 6│& 7│* 8│( 9│) 0│_ -│+ =│ BacSp │ │Ins│Hom│PUp│ │N L│ / │ * │ - │
 * ├───┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─────┤ ├───┼───┼───┤ ├───┼───┼───┼───┤
 * │ Tab │ L │ X │ D │ R │ T │ Y │ U │ I │ O │ P │{ [│} ]│ | \ │ │Del│End│PDn│ │ 7 │ 8 │ 9 │   │
 * ├─────┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴─────┤ └───┴───┴───┘ ├───┼───┼───┤ + │
 * │ Caps │ A │ S │ D │ F │ G │ H │ J │ K │ L │: ;│" '│ Enter  │               │ 4 │ 5 │ 6 │   │
 * ├──────┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴────────┤     ┌───┐     ├───┼───┼───┼───┤
 * │ Shift  │ Z │ X │ C │ V │ B │ N │ M │< ,│> .│? /│  Shift   │     │ ↑ │     │ 1 │ 2 │ 3 │   │
 * ├─────┬──┴─┬─┴──┬┴───┴───┴───┴───┴───┴──┬┴───┼───┴┬────┬────┤ ┌───┼───┼───┐ ├───┴───┼───┤ E││
 * │ Ctrl│    │Alt │         Space         │ Alt│    │    │Ctrl│ │ ← │ ↓ │ → │ │   0   │ . │←─┘│
 * └─────┴────┴────┴───────────────────────┴────┴────┴────┴────┘ └───┴───┴───┘ └───────┴───┴───┘
 */
```

# 第二章 正则表达式位置匹配攻略


## 断言
**更方便大家理解，举一个例子：**
1. 正向先行断言(正向零宽断言)：exp1(?=exp2) 查找exp2前面的exp1
```
'中国人'.replace(/中(?=国人)/, 'rr')
输出：rr国人
```

2. 反向先行断言：(?<=exp2)exp1 查找exp2后面的exp1
```
'中国人'.replace(/(?<=中国)人/, 'rr')
输出：中rr
```

3. 负正向先行断言（负向零宽断言）：exp1(?!exp2)查找后面不是exp2的exp1
```
'中国人中'.replace(/中(?!国人)/, 'rr')
输出："中国人rr"
```

4. 负反向先行断言：(?<!exp2)exp1查找前面不是exp2的exp1

```
'中国人中'.replace(/中(?<!国人)/, 'rr')
输出："rr国人中"

"abZWab863ab88".replace(/(?<![A-Z])ab/g, "")
输出："ZWab86388"
```
















