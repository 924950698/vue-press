# RegExp篇二

```type={1,2,11,12}
/***
 *
 * ███████▒█    ██  ▄████▄   ██ ▄█▀       ██████╗ ██╗   ██╗ ██████╗
 * ▓██   ▒ ██  ▓██▒▒██▀ ▀█   ██▄█▒        ██╔══██╗██║   ██║██╔════╝
 * ▒████ ░▓██  ▒██░▒▓█    ▄ ▓███▄░        ██████╔╝██║   ██║██║  ███╗
 * ░▓█▒  ░▓▓█  ░██░▒▓▓▄ ▄██▒▓██ █▄        ██╔══██╗██║   ██║██║   ██║
 * ░▒█░   ▒▒█████▓ ▒ ▓███▀ ░▒██▒ █▄       ██████╔╝╚██████╔╝╚██████╔╝
 *  ▒ ░   ░▒▓▒ ▒ ▒ ░ ░▒ ▒  ░▒ ▒▒ ▓▒       ╚═════╝  ╚═════╝  ╚═════╝
 *  ░     ░░▒░ ░ ░   ░  ▒   ░ ░▒ ▒░
 *  ░ ░    ░░░ ░ ░ ░        ░ ░░ ░
 *           ░     ░ ░      ░  ░
 */

```

## 正则要么匹配字符，要么匹配位置。
元字符：
* 两种模糊匹配
* 字符组
* 量词
* 分支结构
* 案例分析

1. 纵向匹配 和 横向匹配
2. 字符组：范围表示法 [] ， 
 <br> 排除字符组 ^（脱字符），
 <br> 范围字符组 /d , /D , /w , /W , /s , /S 和 . 七种。请看下图：



3. 量词 
**简写形式** {m,}
4. 贪婪与惰性匹配
**贪婪匹配：** 条件范围内，越多越好。<br>
**惰性匹配：** 条件范围内，尽可能少的匹配。通过在量词后面加个？就可以实现惰性匹配。

5. 多选分支
| （管道符，或）也是惰性的，匹配上以后就不会在继续匹配了。

6. 匹配十六进制的颜色

```type={15}
var regex = /#\w{3,6}/ig
var string = "#ffbbad #Fc01DF #FFF #ffE";
console.log( string.match(regex) );
//输出：#ffbbad #Fc01DF #FFF #ffE

var regex = /#\w{3,6}$/ig
var string = "#ffbbad #Fc01DF #FFF #ffE";
console.log( string.match(regex) );

/* 重点1：
	加上$符号以后，为啥只能匹配一条 #ffE ？
	$限定结尾，又因为正则表达式中，含有“#”；所以只能是从最后一个“#”开头的字符串开始。
*/

//如果换成：var regex = /^#\w{3,6}$/ig

/* 重点2：
	结果就会变成null。因为：string是一个字符串，不是4个字符串。
	而以“#”号开头，以最后一位字母结尾。已经不是在3-6位之间了。
	所以，string是不符合regex规则的，返回null。
*/
```

7. 匹配时间（以24小时为例），实现以下匹配:

**23:59 <br>
02:07**

```type={1}
//这道题需要想一下，24时制的4位数字分别有什么特征。

var regex = /([01][0-9]|[2][0-3]):([0-5][0-9])/g
var date = '23:59 02:07'
console.log(date.match(regex))// 输出23:59 02:07
```

现在加入也需要匹配：7:9 （时分前面的“0”可以省略）的情况呢？
```
  var regex = /(0?[0-9]|1[0-9]|[2][0-3]):(0?[0-9]|[1-5][0-9])/g;
  var date = '23:59 02:07 7:9'
  console.log(date.match(regex))//输出：23:59 02:07 7:9
```
**Tips：**<br>
	写到这，觉得"^" 和 "$"这两个字符有必要总结一下。这两个限定符不能随便用，之前没注意到，踩了太多坑。<br>如果想匹配这种"aa ab ac ba bd"
的字符串格式下的子串。一旦限定开头和结尾，由于搜索的是一整个字符串，所以结果马上就变得截然相反。大家慎用。

8. 匹配日期 2017-09-09

```
	var regex = /[0-9]{4}\-(0?[1-9]|1[0-2])\-([0-2][0-9]|3[0-1])/g
	var date = '2017-09-09'
	console.log(date.match(regex))
```

**上面的正则没有考虑到“日”为一位数时，不能是0的情况。即“2019-09-00”，正常情况下是不会有这种情况出现的。**

```
	/[0-9]{4}\-(0?[1-9]|1[0-2])\-(0[1-9]|[12][0-9]|3[01])/g
```

**Tips：**
另外，使用“[]”范围符时，如果是1-2，2-3这种相邻的范围。可以把-省略掉。

9. window 操作系统文件路径匹配

**因为文件夹的名字不能是特殊字符，那么就要首先确定一个问题：js的正则中的特殊字符都有哪些？**

```
初步断定有以下几种：
~!@#$%^&*()/\|,.<>?"'();:_+-=\[\]{}

var regex = /^[a-zA-Z]:\\([^\\:*<>|"?\r\n/]+\\)*([^\\:*<>|"?\r\n/]+)?$/;
console.log( regex.test("F:\\study\\javascript\\regex\\regular expression.pdf") );
console.log( regex.test("F:\\study\\javascript\\regex\\") );
console.log( regex.test("F:\\study\\javascript") );
console.log( regex.test("F:\\") );
// => true
// => true
// => true
// => true
```

10. 匹配id

```
var string='<div id="container" class="main"></div>'
var regex = /id=".*"/
输出：id="container" class="main"

Tips:
	因为*是贪婪匹配，所以会一直匹配到最后一个"才结束。
	所以，我们加一个?使用非贪婪模式来匹配即可。

var string='<div id="container" class="main"></div>'
var regex = /id=".*?"/
输出：id="container"
```

**后记：**
<br>这一章只记录一些基本的正则操作。




















